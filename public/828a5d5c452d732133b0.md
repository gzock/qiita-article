---
title: nRF54L15 を使って Bluetooth v6 の チャネルサウンディング(Channel Sounding) をやってみる
tags:
  - bluetooth
  - IoT
  - Nordic
private: false
updated_at: '2025-12-26T12:17:19+09:00'
id: 828a5d5c452d732133b0
organization_url_name: null
slide: false
ignorePublish: false
---
## nRF54とは？

**nRF54** は、Nordic Semiconductor が提供している次世代のワイヤレス SoC ファミリーになる。

これまで広く使われてきた nRF52 / nRF53 シリーズの後継にあたり、純粋なマシンパワーの向上、さらなる低消費電力化を果たしている。さらに、Bluetooth V6を公式的にサポートしており、その中の目玉機能の1つである チャネルサウンディングを使って今までにない高精度な測距が可能になっている。

今年の前半ぐらいまではまだ量産開始してまもないということもあって、あまり世の中でnRF54を使った実例は少なかった。しかし今だと開発ボードも手に入りやすいし、後述するように¥2000アンダーでnRF54ボードを使って簡単に試し始める土壌が整ってきている。

まぁnRF54の話自体は先人たちが大量に良記事を書いてくださっているのでググるかLLMに聞いてみて欲しい。

---

## チャネルサウンディング（Channel Sounding）とは？

**チャネルサウンディング（Channel Sounding）** とは、

無線通信において **デバイス間の電波の伝わり方（チャネル特性）を測定する技術**のことだ。

Bluetooth LE においては、主に次のような目的で使われる。

- デバイス間の距離を測る（測距）
- マルチパス（反射）を考慮した位置推定
- RSSI だけに頼らない高精度な距離推定

### 従来のRSSI ベースの測距との違い

従来の Bluetooth 測距では、RSSI（受信信号強度）を使う方法が一般的だった。

しかしこの方法には、

- 環境の影響を非常に受けやすい
- 人や壁があるだけで値が大きく変わる
- 精度が数メートル単位になりがち

といった問題がある。

チャネルサウンディングでは、

- 電波の往復時間（Time of Flight）
- 複数チャネルでの位相情報
- 周波数ごとの応答の変化

といった情報を使って解析する。

そのため、RSSI に比べて **物理的に筋の良い測距**ができ、cm レベルの精度を狙えるのが大きな特徴になる。

・・・まぁ実際にはだいぶ難しいのだが、それでも今までのBLEの測距に比べれば圧倒的に高精度になっているのは間違いない。

# 用意するもの

- 公式の開発ボードである `nRF54L15DK`
    - https://www.nordicsemi.jp/tools/nrf54l15dk/
    - お馴染みのNordic公式の開発ボード
    - 少し前までは全然手に入らなかったが今だと結構在庫あることが多く購入しやすい
- Seeed Studio XIAO nRF54L15
    - https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/
    - ここ最近で発売開始したもので親指の第一関節ぐらいまでぐらいのサイズ感
    - 安くて小型ですごい良い

もちろん、どちらか一方だけでもOK, とにかく2枚用意して欲しい。

今回は敢えて別々のボードを用意した。

上がXIAO nRF54L15であり、下が公式のnRF54L15DKである。当たり前の話だが全然サイズが違う。値段も違う。単に Bluetooth v6で遊びたいだけなら XIAO nRF54L15 x2台で全然OK.

![IMG_0438.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/92177971-5055-4c6a-8123-dd99ae628ad9.jpeg)


# 前提知識

## チャネルサウンディングにおけるイニシエーターとレスポンダー

Bluetooth のチャネルサウンディングでは、通信する 2 台のデバイスに

**イニシエーター（Initiator）** と **レスポンダー（Responder）** という役割がある。

名前の通り、

- **イニシエーター**：測定を開始する側
- **レスポンダー**：要求に応答する側

という関係になっている。

---

## イニシエーター（Initiator）の役割

**イニシエーター** は、チャネルサウンディング全体を主導する側のデバイスになる。

主な役割は以下の通り。

- チャネルサウンディングの開始要求を送信する
- 測定シーケンス（チャネル切り替えやタイミング）を制御する
- 受信した信号をもとに **距離計算や解析を行う**

要するに、

**「測りたい側」「結果を使う側」** がイニシエーターになることが多い。

例えば… 

- スマートフォン → イニシエーター
- スマートロック / タグ / デバイス → レスポンダー

という構成になりえると思う。

---

## リフレクター（Reflector）の役割

リフレクター は、イニシエーターからの要求に応答する側のデバイスである。

主な役割は以下の通り。

- イニシエーターからの測定要求を受信する
- 指定されたタイミング・チャネルで信号を返す
- 測定が成立するよう、正確な応答を行う

レスポンダーは、基本的に **自分で距離を計算しない**。

あくまで、イニシエーターが正確に測定できるように **「決められた仕様通りレスポンスを返す」だけの役割** を担う。

そのため、

- 実装が比較的シンプル
- 消費電力を抑えやすい

というメリットがあり、バッテリー駆動の小型デバイス側でこのロールを持つのに向いている。

---

# やってみよう

## nRF54L15DKをイニシエーター化する

VS Code使ってたらくっそ簡単！もちろんCLIベースでも全部できる。その場合は [公式ガイド](https://docs.zephyrproject.org/latest/develop/getting_started/installation_linux.html#installation-linux)をどうぞ。あるいは、[私が書いた以前の記事](https://qiita.com/gzock/items/2c5575c61a5a714ee253) も参考になるのでどうぞ。

今回は、NRF54L15DKをイニシエーターとし、Seeed Studio XIAO nRF54L15をリフレクターとする。

## 1. 開発環境の構築

1. VS Code の拡張で **“nRF Connect for VS Code Extension Pack”** を入れる
2. VS Code 左の nRF Connect アイコンから
    - **Install Toolchain**（最新をいれる, 今だと 3.2.1かな？）
    - **Manage SDKs**（同じバージョンの nRF Connect SDK を入れる）

---

## 2. アプリケーションの追加

nRF Connect SDK の中に既にチャネルサウンディングのサンプルがある。対象はこれら。色々アップデート入ってる別版もあるのだが、まぁ最初は一番スタンダードのやつからで。

- **Initiator（Ranging Requestor + Channel Sounding initiator）**
    - [`samples/bluetooth/channel_sounding_ras_initiator`](https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/samples/bluetooth/channel_sounding_ras_initiator/README.html)
- **Reflector（Ranging Responder + Channel Sounding reflector）**
    - [`samples/bluetooth/channel_sounding_ras_reflector`](https://docs.nordicsemi.com/bundle/ncs-latest/page/nrf/samples/bluetooth/channel_sounding_ras_reflector/README.html)

1. VS Code > nRF Connect > **Create a new application >** Copy a sample
2. `channel_sounding_ras_initiator` を選択してアプリケーション追加

---

## 3. ボードターゲットを選ぶ（nRF54L15-DK）

追加したサンプルアプリケーションに対して Add build configuration > Build Target で以下を選択

- `nrf54l15dk/nrf54l15/cpuapp`

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/a899622d-f17b-4e7b-a070-d6e11a5f7117.png)


![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/41a62a03-03c5-4a71-a0db-dc9f40c67736.png)


### 4. ビルド

サンプルの initiator を選択した状態で、 ACTIONS > Build

### 5. フラッシュ

- nRF54L15DKをUSBでPCにつなぐ
- VS Code の nRF Connect 画面で **Connected devices** に出ていることを確認
- ACTIONS > Flash

## Seeed Studio XIAO nRF54L15 をリフレクター化する

https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/  を見ながら進める。

とはいえ、実は既にVS Codeで環境構築できている状態なので、めっちゃ楽。

# ボードの追加

拡張機能をインストールしたデフォ状態ではサードパーティのボードであるSeed Studioの存在がない。そのため、別途 ボードの定義を追加する。

記事に書こうかと思ったが、公式ガイド以上の話がないので、こちらを参考にどうぞ。めっちゃ簡単です。

[https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/#xiao-nrf54l15-ボードの追加](https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/#xiao-nrf54l15-%E3%83%9C%E3%83%BC%E3%83%89%E3%81%AE%E8%BF%BD%E5%8A%A0)

## 書き込みプラグインの用意

nRF54L15DKの場合と同じくUSB接続するだけで書き込みはできるのだが、違うのは OpenOCDを使うっていう部分。

まぁこの記事を見ている人たちならOpenOCDの環境ぐらいは揃ってそうだが、まだだって言う方はこれもまた公式ガイド側をどうぞ。

[https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/#書き込みプラグインのダウンロード](https://wiki.seeedstudio.com/ja/xiao_nrf54l15_sense_getting_started/#%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E3%83%97%E3%83%A9%E3%82%B0%E3%82%A4%E3%83%B3%E3%81%AE%E3%83%80%E3%82%A6%E3%83%B3%E3%83%AD%E3%83%BC%E3%83%89)

ポイントとして、こちらの作業をしたあと1回 VS Codeを立ち上げ直したほうが良い気がする。確認している事象として、OpenOCDが認識されない状況に陥る場合があった。入ってるのに認識できてないというか。なので、そのときは立ち上げ直したほうが良いと思う。

### そもそも

nRF54L15DK側の手順とほぼ同じ。一部だけ対応が異なるのでそこだけ重点的に紹介。

## 2. アプリケーションの追加

1. VS Code > nRF Connect > **Create a new application >** Copy a sample
2. `channel_sounding_ras_reflector` を選んでプロジェクト作成
    
![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/0f1d0e54-59a6-4305-a1dc-0d5d0b33eb54.png)


## 3. ボードターゲットを選ぶ（Xiao nRF54L15）

**Add build configuration >** `xiao_nrf54l15/nrf51l15/cpuapp` を選択。1つ下の Base configuration files で `pj.conf`を選択。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/f96953b3-bc56-4b5a-ac5c-ca3806cbf0bb.png)

### 4. ビルド

サンプルの reflector を選択した状態で、 ACTIONS > Build

### 5. フラッシュ

- XIAO nRF54L15 をUSBでPCにつなぐ
- ただし nRF54L15DKとは違って、この時点で **Connected devices** には表示されないので注意
- ACTIONS > Flash
    - ここでOpenOCD経由で書き込みが走るはず

# 動作確認

両方のボードを起動。このときイニシエーター側でシリアル通信側をターミナルでつないでおく。

そうすると、以下のようなログがでるはず。もし出ないならRESETボタンで再起動させる。

```console
*** Booting nRF Connect SDK v3.2.1-d8887f6f32df ***
*** Using Zephyr OS v4.2.99-ec78104f1569 ***
Starting Channel Sounding Demo
```

あとは、リフレクターと接続完了すると、以下のような感じでチャネルサウンディングによる測距データが表示される。Round-Trip… Phase-Based… と書いてあるとおり、まさにチャネルサウンディングである。従来の電波強度, RSSIに頼ったものではない別の形での測距をしていることが見て取れる。

```console
Connected to FF:FF:A0:FF:24:FF (random) (err 0x00)
MTU exchange success (247)
Security changed to level 2.
CS capability exchange completed.
CS config creation complete. ID: 0
CS security enabled.
CS procedures enabled.
Estimated distance to reflector:
- Round-Trip Timing method: -0.037474 meters (derived from 4 samples)
- Phase-Based Ranging method: 1.137421 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: 1.584617 meters (derived from 7 samples)
- Phase-Based Ranging method: 1.185009 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: -0.719502 meters (derived from 5 samples)
- Phase-Based Ranging method: 1.130389 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: 0.337267 meters (derived from 4 samples)
- Phase-Based Ranging method: 0.981813 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: 1.124222 meters (derived from 6 samples)
- Phase-Based Ranging method: 0.925629 meters (derived from 36 samples)
A reliable distance estimate could not be computed.
Estimated distance to reflector:
- Round-Trip Timing method: -0.419709 meters (derived from 5 samples)
- Phase-Based Ranging method: 0.955317 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: -0.042827 meters (derived from 7 samples)
- Phase-Based Ranging method: 0.862289 meters (derived from 36 samples)
Estimated distance to reflector:
- Round-Trip Timing method: 0.262318 meters (derived from 4 samples)
- Phase-Based Ranging method: 1.033563 meters (derived from 36 samples)
A reliable distance estimate could not be computed.
```

# 精度はどんなもん？

自宅で実験。デバイスや環境によっても結果の精度はバラつくのであくまで参考程度にどうぞ。

| **実際の距離 (mm)** | **測定値の平均値 (mm)** |
| --- | --- |
| 4000 | 4385 |
| 3500 | 3563 |
| 3000 | 3028 |
| 2500 | 2737 |
| 2000 | 2372 |
| 1500 | 1632 |
| 1000 | 1371 |
| 500 | 660 |

遥かに従来のBLEの測距に比べればマシだと思う。もちろんずーっと計測を眺めていると、値がハネるときもあるし、さすがに cm級の精度… とは言い難い。数十cmのズレは全然あり得る。が、cm級で距離を図りたいケースなんて恐らく稀なはずで、欲しいのはある一定の距離まで近づいたら… というユースケースが大半じゃないだろうか。そのレベル感だとすると、従来のBLE測距に比べてかなり信頼性を上げられていると思う。

ちょっと今回はデータを並べられてないのだが、UWBとの比較もできるので、そういう比較も今度別の記事で出してみたいと思う。

# もう少しかっこよく見やすくする

ターミナルでチャネルサウンディングはできるようになった。しかし、これだけど なんかうーん。もうちょっとかっこよくみたいな！ っていうことで webserial を使って ビジュアライズしてみる。

こちらは本題からは逸れるので、コードの説明はしない。リポジトリとして切り出しているので、よければこちらをどうぞ。

https://github.com/gzock/bt-v6-channel-sounding-demo

これはNordicの公式サンプルを使って動かすと、あとはもう↑で可視化可能。

逆に言えば、公式サンプルからイジってあると逆に動かないので注意。改造は簡単だろうけど。

![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/e70cff6c-16bf-4c81-864e-b61f648328e0.png)

# スマホ対応

現状、iOSでもAndroidでもメインラインにおいてはチャネルサウンディングは使えない。

実はスマホだと、iPhone 17シリーズやPixel 10シリーズならBluetooth v6に正式対応している。

- https://www.apple.com/jp/iphone-17/specs/
- https://store.google.com/jp/product/pixel_10_specs

そのためチャネルサウンディングも使えるはずなのだが、SDK的にはまだ使えない。とはいえ、当然 彼らも考えているはずで、2026年にはスマホにおけるチャネルサウンディング元年になる可能性は高い。

実際、実はAndroid v16 QRP2 においてはチャネルサウンディングがサポートされはじめたらしい。
- 参考: https://www.musen-connect.co.jp/blog/course/product/bluetooth-channel-sounding2/

このへんも今後試せそうなら是非やってみたい。

# さいごに

いやーチャネルサウンディングはおもしろい。最初に規格が発表されたときからずっと気になっていたけど、本当におもしろい。

競合はUWBになるだろう。実際に試せばわかるが、正直 UWBには及ばない。流石にあそこまでの精度は出ない。一方で、UWBほどの能力がいるケースってどれだけあるだろうか。

少なくともチャネルサウンディングによって、従来のBLEの測距に比べれば圧倒的な精度を実現している。

UWBの場合は専用チップが当然必要になる。もちろんチャネルサウンディングでもそうだけれども、今後 v6対応のBTチップがどんどん世の中に広まっていくのは間違いない。

勝手に広がっていくチャネルサウンディングと、意図して実装しなければ使えないUWB… と考えると、かなりチャネルサウンディングはアリだと思う。

もちろん世の中のユーケース的にUWBまでの精度を必要としない場合もあるだろう。とはいえ従来のBLE測距じゃダメだったが、チャネルサウンディングのレベルの測距なら実用可能… というケースは世の中的に非常に多いんじゃないだろうか。
