---
title: Atmosic ATM3330e を使って無線によるウェイクアップを試してみる
tags:
  - IoT
  - Nordic
  - Zephyr
private: false
updated_at: '2025-12-25T19:24:43+09:00'
id: 2c5575c61a5a714ee253
organization_url_name: null
slide: false
ignorePublish: false
---
# 本ページの概要

- Atmosic / ATM3330e がどんなMCUなのか
- Zephyr + OpenAir を使った基本的な動かし方
- Atmosicの目玉機能である WuRX（無線ウェイクアップ）を実際に試す

## Atmosic社とは

2016年に創業した `Atmosic（Atmosic Technologies）` は、超低消費電力に特化したBluetooth SoCベンダー。競合はもちろん `Nordic` になる。

ウェイクアップ技術やエナジーハーベスティング、空間伝送型のワイヤレス給電など様々な面白い技術を1チップに統合している。

古い人間にはおなじみのAtherosのエンジニアたちが独立して立ち上げた会社でもある。知ってる人からするとその事実だけでも、オッてなると思う。自分はなった。

より電池寿命を重視するBLE機器の場合にはこちらを使うことでのメリットは結構あるかもしれない。

ちなみに個人的にはこの記事がわかりやすくておもしろかった。

https://techblitz.com/startup-interview/atmosic/

---

## ATM3330e（ATM33 Series）のメリット

- https://atmosic.com/products/the-atm33-series/
- 現在の主力MCUの1つ
- **NordicのようなBluetooth Low Energy統合MCUであり、そもそも非常に低消費電力**
- センサー連携やボタン電池駆動のIoTデバイスに最適
- 無線＋MCUがワンチップで、省部品・省スペース設計が可能
- エナジーハーベスティング（環境発電）用途との親和性が高い
- 対Nordicでいうと、nRF52相当だと思えば良いかもしれない
    - nRF54級のものはまだ量産前のATM34シリーズが相当する

---

# 実装事例

- Samsungのスマートタグ第2世代に採用され、公式発表ベースでバッテリー寿命が約3倍に向上
    - https://atmosic.com/samsung_smarttag2/
    - https://atmosic.com/press_release/samsung-galaxy-smarttag2-uses-atmosics-ultra-low-power-soc-to-extend-battery-life/
    - https://news.samsung.com/jp/galaxy-smarttag2
- その他、テレビのリモコンなどにも採用

# 技術的特徴

- ウェイクアップレシーバー機能：デバイスが完全に休止状態でも特定の信号で起動可能
- 電力モード：チップフェーズ、ハイバネーション、リテンション、アイドル、フルアクティブなどの状態を細かく制御
- エネルギーハーベスティングがデフォルトで対応
    - 実際、後述の開発ボードでも小型のソーラーパネルが付属しており、それで簡単に試し始められる

# 懸念点

- 日本語資料は非常に少なくノウハウもなかなかない
- 公式ドキュメントやツール、SDKもNordicに比べるとまだ弱い
    - それでも創業10年経ってないメーカーにしては全然サポート強いと個人的には思う
- (後述するが) 各種機能にクセがあり、大本営発表だけを鵜呑みにするべきではない

## どんなケースに向いているMCUか？

- とにかく低消費電力… 電池寿命を最優先したBLEデバイスを作りたい
    - センサータグ / リモコン / スマートロックなどなど
- スリープを多用することになるので、それ前提でのシステム設計ができるユースケースに合致する

# Atmosic ATM3330eを試してみる

## 利用デバイス

- 開発ボードである**ATMEVK-3330e を利用**
    - https://atmosic.com/products_kit_atmevk-3330e/
- MacBook M3 Pro: Tahoe 26.1
    - ツール構成的にはたぶんWindowsのほうが色々楽だと思う

まぁよくある開発ボードっていう感じのサイズ感。Mouserなどでも購入可能。

![IMG_0439.jpeg](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/2f6a21f0-d6f1-4f43-affc-e5f3772d7d25.jpeg)


## 前提

- 元々は彼らのSDKベースでベアメタルに動かしていたのだが、最近 正式に `Zephyr`がサポートされた
- とにかくZephyrでの利用が簡単で扱いやすいので、今回はその方法を紹介

## 大事: 要確認

モノにもよるかもしれないが技適がないケースがあるので、その場合はシールドルームの中で作業するとか特例申請だすとか、何かしらの手法によって合法的に扱える準備を整えておくこと。

## 注意

- ボードの裏側にコイン電池搭載しているなら特に問題なし
- コイン電池なしの場合は、 `J21` のジャンパーを `VBAT-3V` 側にしておく
    - これをやらないと電圧があわないので書き込みに失敗する

## 事前準備

つないだ手持ちのボードのシリアルNoを把握する。これを使ってこのあと書き込みするので。

※ボード裏側にシールがはってあってそこに書いてあるケースもアリ

```console
JLinkExe <<<'ShowEmuList
q'

```

- S/N あるいは Serial number の部分を控えておく

```console
SEGGER J-Link Commander V8.50 (Compiled Jul  9 2025 14:43:18)
DLL version V8.50, compiled Jul  9 2025 14:42:42

Connecting to J-Link via USB...O.K.
Firmware: J-Link OB-K22-Cortex-M compiled Apr  1 2025 10:13:14
Hardware version: V1.00
J-Link uptime (since boot): 0d 00h 00m 17s
S/N: 999999999
USB speed mode: Full speed (12 MBit/s)
VTref=3.300V

Type "connect" to establish a target connection, '?' for help
J-Link[0]: Connection: USB, Serial number: 999999999, ProductName: J-Link-OB-K22-CortexM
```

## まずZephyrを使えるようにする

https://docs.zephyrproject.org/latest/develop/getting_started/index.html を見てやればいい

```console
$ brew install cmake ninja gperf python3 python-tk ccache qemu dtc libmagic wget openocd

(echo; echo 'export PATH="'$(brew --prefix)'/opt/python/libexec/bin:$PATH"') >> ~/.zprofile
source ~/.zprofile
```

- venvを使って切り分け
- ZephyrのCLIツールである `west`はpipで一発インストール可能

```console
$ python3 -m venv ~/zephyrproject/.venv
$ source ~/zephyrproject/.venv/bin/activate

$ pip install west
```


## OpenAir を準備する

OpenAir とはAtmosicのZephyr仕様のこと。

https://atmosic.com/public/OpenAir_SDK_doc/getting_started_guide/installation.html#installation

を見ながら準備する。Atomisc社のMCUを利用しZephyrを使うならこのOpenAIRベースでの開発と鳴る。

専用ツールとして **`atmoautil`** というのもあるのだが、こちらがmacOSに対応してないっぽくて、私はこちらを使っていない。Windowsなら使えるようなので、Windowsユーザーはそちらで準備したほうが楽かもしれない

少なくとも数分はかかるはずなので気長に待ちましょう。最後のSDKインストールのときはSASEが導入された環境だと証明書エラーが出る可能性があるので注意。

```console
$ west init -m https://github.com/Atmosic/openair.git zephyrproject
$ cd zephyrproject
$ west update

$ west zephyr-export
$ west packages pip --install

$ cd zephyr
$ west sdk install
```

- ビルド
    - このとき `-b`のボード指定で `ATMEVK-3330e-QN-7`を指定する。購入タイミングでリビジョンが違うようなので、場合によっては -6 であったり -8 であるかもしれない点に注意
    - まぁここが違ってもぶっちゃけ動く

```console
$ west build -p always -b ATMEVK-3330e-QN-7 openair/samples/sysbuild/hello_world --sysbuild -T samples.sysbuild.hello_world.atm
```

- フラッシュ

```console
$ west flash --skip-rebuild --device 999999999 --jlink --fast_load
```

- 動作確認
    - 少なくとも私の環境の場合は /dev/cu.usbmodem000{SerialNo}という形式で存在するのでそこにシリアル通信を見ればOK
    - 上述のHelloWorldのサンプルコードの場合は、起動したタイミングで HelloWorldの文字が見えればOK

```console
$ minicom --wrap --device  /dev/cu.usbmodem000{SerialNo}
```

ここまで出来たらもうバッチリ。あとはもう煮るなり焼くなりどうぞ

# WuRXを試してみる

## WuRXとは？

- 無線を使ったウェイクアップ機能のこと
- 普段はMCUとして停止しつつ、ウェイクアップする部分だけ常時起動して信号を待ち受ける
- 所定の無線信号を受け取ったらMCUを立ち上げメイン処理が始まっていく
- 何らかのGPIOなどを使って別からウェイクアップされる…とかは非常によくある手法だと思うが、このようにMCUレベルで無線経由でウェイクアップできるのは珍しく、そして面白い
- 用途にもよると思うが、普段はディープスリープ状態になっていられるので消費電力的にかなり優位に働くはず

## 事前準備

スマホアプリからウェイクアップの無線信号を流して動作確認することができる。AtmosicのDevToolがストアに公開されているのでこちらをインストールしておくこと

- https://apps.apple.com/jp/app/atmosic-devtools/id1592941402

ちなみにAndroid版もあるので、必要に応じてそちらもどうぞ。

開発ボードは、付属のアンテナをWURX側のSMAに接続しておくこと。後述するが、ウェイクアップはかなりシビアなのでそれこそアンテナついてない状態だと話にならなかったりする。

## 参考資料

まずベースとして以下のガイドが参考になる。

https://atmosic.com/public/OpenAir_SDK_doc/openair/samples/drivers/wurx/README.html

まぁここに書かれている通り、特定の無線信号が検出されるとディープスリープ状態からオンデマンドにメインMCUを起動させることができる。でもって、どうやってそれやってんの？についてはさすがにここにも書かれてない。

## どういう技術か？

パブリックに見れる情報では正直 技術的な詳細は得られない。それこそ↑のサンプルアプリケーションガイドに載ってる情報ぐらいだろう。

ちなみに正式ルートでボードを手に入れてアカウントをもらえたら、Atmosic社の専用サイトから色々ドキュメントをダウンロードできる。

そちらを見れば、具体的にどういうことをやっているのか？がイメージできるようになるはず。

さすがに非公開な話をここに書くわけにもいかないので詳細は割愛。そちらの公式ドキュメントを読んでください。

例えば以下のようなホワイトペーパーもあるのだが、これもまたアカウントを持っていないと見れない。

[https://atmosic.com/?swp_form[form_id]=1&s=wakeup](https://atmosic.com/?swp_form%5Bform_id%5D=1&s=wakeup)

## ウェイクアップの手法

特定の無線信号…には選択肢がある。正確にいうと、任意の無線信号を仕込んでおいてそれでウェイクアップできるのだが、サンプルではそういうコードは提供されていなくて、以下の選択肢から選ぶことになる

- **Bluetooth Inquiry Scan**
- **BLE iBeacon Advertise**
- **BLE High Duty Advertise**

**Bluetooth Inquiry Scan** とはいわゆるBluetooth Classicで使われる周辺のBluetooth機器のスキャンのこと。PCとかスマホで何かBluetooth機器をペアリングして使おう！としたときには事前にこの種類のスキャンを使っている。BLEのスキャンとは異なるものなので注意。

**iBeacon** はいわずもがな、BLEビーコンのApple仕様のやつである。世の中で市販されているビーコンはまず間違いなくiBeacon仕様に則っている。もう世の中にうまれて10年以上になるので、非常によく使われている技術の1つであろう。

**BLE High Duty Advertise** は世の中にあるものではなく本来のBLEではありえないような超高頻度のアドバタイズに寄って、それを特徴的な無線信号として認識してウェイクアップさせる独自の機能のこと。

で、どれを使うか？だが、**圧倒的おすすめは iBeaconのやつ。**

まずBluetooth Inquiry Scanは私が試す限りうまくいってない。ビルドもフラッシュもできるが、実際のウェイクアップに今のところ成功していない。

BLE High Duty AdvertiseはAtmosicの開発ボードを最低でも2台は必要になる。まぁあるならそれでもOKだが、結構高いものになるので、手元に1台だけ…というケースも多いだろう。

ということで、扱いやすく、簡単に動作確認もできる iBeaconのパターンがおすすめ。

## 試してみる

さて、早速試してみよう。上述の通り、個人的には圧倒的にiBeaconのパターンがおすすめなので、まずはこれで。とはいえ、他のを試したいにしても、ビルドをちょこっと変えるだけなので楽勝ではある。

- ビルド
    - Bluetotth Inquiry Scan の方を試したいなら、最後のoverlayの部分を 同ディレクトリの `bt_inquiry.overlay`に変えればOK

```console
$ west build -p always -b ATMEVK-3330e-QN-7 \
    openair/samples/drivers/wurx --sysbuild \
    --  -DCONFIG_WURX=y \
    -DEXTRA_DTC_OVERLAY_FILE="~/zephyrproject/openair/doc/wurx/ibeacon.overlay"
```

- フラッシュ

```console
$ west flash --device 999999999 --jlink --fast_load \
    --elf-file ~/zephyrproject/build/wurx/zephyr/zephyr.elf
```

## 動作確認

事前にシリアル通信側を立ち上げておくこと。起動すると以下のようなログが見えてディープスリープ状態になるはず。

```console
[00:00:00.001,000] <inf> wurx_atm: Initializing WuRx driver
[00:00:00.001,000] <dbg> wurx_atm: wurx_atmosic_init: WuRx PMU register configuration:
[00:00:00.001,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx_general:  0x00202600
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx_general2: 0x000320c8
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init: WuRx0 algorithm registers:
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx0_0: 0x0000aaaa (UID pattern)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx0_1: 0x0000aaaa (GID pattern)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx0_2: 0x0a0f78d0 (correlation/threshold config)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx0_3: 0x20100c04 (energy thresholds/clock freq)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx0_4: 0x08802013 (timer/algorithm control)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init: WuRx1 algorithm registers:
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx1_0: 0xaaaaaaaa (UID pattern)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx1_1: 0xffffffff (GID pattern)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx1_2: 0x0c0a515f (correlation/threshold config)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx1_3: 0x20100c04 (energy thresholds/clock freq)
[00:00:00.002,000] <dbg> wurx_atm: wurx_atmosic_init:   wurx1_4: 0x0880200f (timer/algorithm control)
[00:00:00.003,000] <dbg> wurx_atm: wurx_atmosic_init: Algorithm enable status: WuRx0=enabled, WuRx1=enabled
[00:00:00.003,000] <dbg> wurx_atm: wurx_atmosic_init: Timing configuration:
[00:00:00.003,000] <dbg> wurx_atm: wurx_atmosic_init:   wake_timeout_ms:     500 ms
[00:00:00.003,000] <dbg> wurx_atm: wurx_atmosic_init:   consecutive_signals: 4
[00:00:00.003,000] <dbg> wurx_atm: wurx_atmosic_init:   signal_spacing_ms:   250 ms
[00:00:00.003,000] <dbg> wurx_atm: wurx_configure_hw: Configuring PMU WuRx registers
[00:00:00.004,000] <dbg> wurx_atm: wurx_configure_hw: WuRx_CONFIG1=0x00000012 (wurx_src_sel=2, consecutive_signals=4)
[00:00:00.004,000] <dbg> wurx_atm: wurx_configure_hw: WuRx_CONFIG2=0x40004000 (signal_spacing=8192 LPC, wake_timeout=16384 LPC)
[00:00:00.004,000] <inf> wurx_atm: WuRx driver initialized successfully
*** Booting Zephyr OS build 328fc0c85e2f ***
*** OpenAir v25.11.0 (NO_BLE), bp_freq is 16000000 ***
[00:00:00.005,000] <inf> wurx_sample: WuRx Sample Application Starting
```

あとはこの状態で、事前にインストールしていた Atmosic DevTool > APPLICATIONS > BEACON > Option > Wake Up を叩けばOK

![IMG_0435.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/5a594f49-856f-4388-808f-7f4915e201fd.png)

![IMG_0437.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/80163/fd7e8261-6304-4f44-b2c6-f1067122003b.png)



そのあとログが動いて以下のようなのが見えればOK！成功！
すなわりスリープ状態から起き上がったことを意味する。

```console
WuRx wake-up event detected!
```

## 注意

ぶっちゃけ、ウェイクアップの成功率はマーーーージで環境による。

自宅の環境では色々な機器が動いて2.4Ghz帯で飛び交いすぎているせいか成功率が著しく低い。

環境要因かなぁ？と思って、電波暗箱を用意して、その中で試しみたらほぼ百発百中で成功した。

もし軽く試して全然ウェイク・アップしないやんけ！ ってなったとしても諦めずに環境を整えて再挑戦してみて欲しい。

# さいごに

実際に役に立つかどうかはユースケース次第だとは思うが、このウェイクアップの技術はめちゃくちゃ面白いと思う。少なくとも私はアカウント発行後に落とせる技術資料を見たときに、あーーなるほど！ そういうアプローチおもしろい！ となった。

ただし、いくらメイン側が止まっているとはいえ、それでもウェイクアップのための最小限のRFは動いた状態になる。

上述のアカウント発行時にダウンロードできる資料の情報になるので、詳しいことはここでは書けないが、当然、その最小限のRF回路を動かしている分の消費電力は発生している。

よって、用途によっては、実は低消費電力化に全然寄与してない！というケースもありえる。というか、実際、私のユースケースではそうなっている。

例えば、ボタンとかを押してそれをトリガーにGPIO経由でウェイクアップみたいな場合はそもそも通常時は完全に止まっていられるため、今回の様な手法を用いる必要がない。RF回路を生かしておく必要もないので、更に低消費電力である。

そういう物理的なトリガーを使えず、強烈にバッテリーを持たせたい… つまり可能な限りスリープしている時間を増やしておきたいというケースにおいては、一考の価値が十分にある技術であろうと思う。
